<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #mouseContainer {
      width: 100px;
      height: 100px;
      line-height: 100px;
      text-align: center;
      border: 1px solid #444;
      font-size: 30px;
    }
  </style>
</head>

<body>
  <!-- <button id="colorChg">click colorChg</button> -->

  <!-- <span class="element">WeakMap</span> -->

  <!-- <p>
    <span id="num"></span>
    <button id="addNum">addNum</button>
  </p>
  <p>
    <span id="age"></span>
    <button id="addAge">addAge</button>
  </p> -->

  <div id="mouseContainer"></div>
  <button id="mouseCancel">cancel</button>

  <!-- ES6 -->
  <script>
    (() => {
      // 常规绑定
      const Button = function (id) {
        this.element = document.getElementById(`${id}`)
        this.bindEvent()
      }
      Button.prototype.bindEvent = function () {
        this.element.addEventListener('click', this.colorChg, false)
      }
      // 这是因为当使用 addEventListener() 为一个元素注册事件的时候，事件函数里的 this 值是该元素的引用。 this.element 报错
      Button.prototype.colorChg = function () {
        this.style.backgroundColor = '#1abc9c'
        this.style.color = 'white'
      }
      new Button('colorChg')
    });

    (() => {
      // 箭头函数绑定
      const Button = function (id) {
        this.element = document.getElementById(`${id}`)
        this.bindEvent()
      }
      Button.prototype.bindEvent = function () {
        this.element.addEventListener('click', () => this.colorChg(), false)
      }
      Button.prototype.colorChg = function () {
        this.element.style.backgroundColor = '#1abc9c'
        this.element.style.color = 'white'
      }
      new Button('colorChg')
    });

    (() => {
      // Symbol
      const mySymbol = Symbol('attr');
      const obj = {};
      obj[mySymbol] = 'Hello!';
      console.log(obj)
    });

    (() => {
      // 使用ES5 的语法创建一个迭代器
      const iteration = items => {
        let i = 0
        const next = () => {
          let done = i >= items.length
          let value = done ? undefined : items[i++]
          return {
            value,
            done
          }
        }
        return {
          next,
          // return 方法的使用场合是，如果 for...of 循环提前退出（通常是因为出错，或者有 break 语句或 continue 语句），就会调用 return 方法
          return: () => {
            console.log('return 执行了')
            return {}
          }
        }
      }
      const iterationIns = iteration([1, 2, 3])
      // console.log('iterationIns', iterationIns.next())
      // console.log('iterationIns', iterationIns.next())
      // console.log('iterationIns', iterationIns.next())
      // console.log('iterationIns', iterationIns.next())
      // console.log('iterationIns', iterationIns.next())

      // 拥有Symbol.iterator 属性 才可被遍历 TypeError: iterator is not iterable
      const obj = {
      };

      obj[Symbol.iterator] = () => iteration([1, 2, 3])

      for (value of obj) {
        // break 会调用迭代器的 return 方法
        if (value == 2) break
        console.log(value);
      }

      // 自定义 for of 遍历方法
      const forOf = (obj, callBack) => {
        // console.log('iterator', obj[Symbol.iterator]().next())
        let iterator = obj[Symbol.iterator]()
        let result = iterator.next()
        while (!result.done) {
          callBack(result.value)
          result = iterator.next()
        }
      }
      forOf(obj, value => console.log('value', value))
    });

    (() => {
      // 内置迭代器 keys() values() entries()
      const user = {
        name: 'xm',
        age: 22
      }

      const frs = ['xh', 'xw']
      // console.log(Object.keys(user))
      // console.log(Object.values(user))
      // console.log(Object.entries(user))

      for (let [key, val] of Object.entries(user)) {
        // console.log(`${key}: ${val}`)
      }

      for (let [key, val] of frs.entries()) {
        // console.log(`${key}: ${val}`)
      }

      // 数组和 Set 集合的默认迭代器是 values() 方法，Map 集合的默认迭代器是 entries() 方法。
      let setArr = new Set([1, 2, 3])
      for (let v of setArr) {
        console.log('setValue', v)
      }

      let mapArr = new Map()
      mapArr.set(Array, '[]')
      mapArr.set(function () { }, 'function')
      for (let [key, value] of mapArr) {
        console.log('mapItem', `${key}: ${value}`)
      }
    });

    (() => {
      // 模拟实现一个简单的 Set 数据结构，实现 add delete has clear forEach 方法
      function Set(list) {
        this.values = []

        for (let v of list) {
          this.add(v)
        }
      }

      Set.prototype.size = function () {
        return this.values.length
      }

      Set.prototype.add = function (v) {
        if (!this.values.includes(v)) {
          this.values.push(v)
        }
      }

      Set.prototype.delete = function (v) {
        if (this.values.includes(v)) {
          this.values.splice(this.values.findIndex(item => item == v), 1)
        }
      }

      Set.prototype.has = function (v) {
        return this.values.includes(v)
      }

      Set.prototype.clear = function () {
        this.values.length = 0
      }

      Set.prototype.forEach = function (callBack) {
        for (let [k, v] of this.values.entries()) {
          callBack(k, v)
        }
      }

      // 迭代器相关......

      let setIns = new Set([1, 2, 2, 3, 4])
      // setIns.delete(2)
      // console.log('has', setIns.has(2))
      // setIns.clear()
      // setIns.add(NaN)
      // setIns.add(NaN)
      // setIns.forEach((k, v) => {
      //   console.log(`${k}: ${v}`)
      // })
      console.log('setIns', setIns)
    });

    (() => {
      // WeakMap
      const map = new WeakMap();
      const attr1 = {
        flag: 'attr1'
      }
      const attr2 = ['attr2']
      map.set(attr1, 1)
      map.set(attr2, 2)
      // console.log('map', map)

      let wm = new WeakMap(), element = document.querySelector(".element");
      wm.set(element, "data");

      let value = wm.get(element);
      // console.log('value', value); // data

      element.parentNode.removeChild(element);
      element = null;

      console.log('element', element)
      console.log('wm', wm)
    });

    // async
    (() => {
      (async () => {
        function getList() {
          console.log('action getList')
          return new Promise((resolve, reject) => {
            setTimeout(() => {
              console.log('getList')
              resolve('getList')
            }, 2000)
          })
        }
        function getAnotherList() {
          console.log('action getAnotherList')
          return new Promise((resolve, reject) => {
            setTimeout(() => {
              console.log('getAnotherList')
              resolve('getAnotherList')
            }, 3000)
          })
        }
        // 无关联的同步请求也会等待上一个方法执行结束
        // const list = await getList();
        // const anotherList = await getAnotherList();

        // 同时执行 顺序返回
        // const listPromise = getList();
        // const anotherListPromise = getAnotherList();
        // await listPromise;
        // await anotherListPromise;

        // Promise.all
        Promise.all([getList(), getAnotherList()])
          .then((data) => {
            console.log('data', data)
          });
      })();
    });

    // defineProperty
    (() => {
      let obj = {}
      Object.defineProperty(obj, 'num', {
        value: 96,
        writable: true,
        enumerable: true,
        configurable: true
      })
      // console.log(obj)

      // 读写 记录监听
      function Archiver() {
        let value = null
        let archivers = []
        archivers.push({ value: value })
        Object.defineProperty(this, 'num', {
          get: function () {
            console.log('getter')
            return value
          },
          set: function (curValue) {
            console.log('setter')
            value = curValue
            archivers.push({ value: value })
          }
        })
        this.getArchiver = function () {
          if (archivers.length > 2) {
            return archivers.slice(archivers.length - 2)
          }
          return archivers
        }
      }
      let insArchiver = new Archiver()
      // insArchiver.num = 96
      // insArchiver.num = 97
      // insArchiver.num = 98
      // console.log(insArchiver.num)
      // console.log(insArchiver.getArchiver())

      // 数据更改视图
      // let numObj = {
      //   num: 0
      // }
      // let value = 0
      // document.getElementById('num').innerHTML = value
      // Object.defineProperty(numObj, 'num', {
      //   get: function() {
      //     return value
      //   },
      //   set: function(curValue) {
      //     value = curValue
      //     document.getElementById('num').innerHTML = value
      //   }
      // })

      // console.log(document.getElementById('addNum'))
      // document.getElementById('addNum').addEventListener('click', function() {
      //   numObj.num++
      // })

      // watch api
      function watch(obj, attr, eleId, fnc) {
        let value = obj[attr]
        Object.defineProperty(obj, attr, {
          get() {
            return value
          },

          set(curValue) {
            value = curValue
            document.getElementById(eleId).innerHTML = value
            fnc()
          }
        })
        obj[attr] = value
      }
      let valueObj = {
        num: 0,
        age: 16
      }

      watch(valueObj, 'num', 'num', function () {
        console.log('callBack num')
      })

      document.getElementById('addNum').addEventListener('click', function () {
        valueObj.num += 1
      })


      watch(valueObj, 'age', 'age', function () {
        console.log('callBack age')
      })

      document.getElementById('addAge').addEventListener('click', function () {
        valueObj.age += 1
      })

    });

    // proxy
    (() => {
      // var proxy = new Proxy({}, {
      //   get: function (obj, prop) {
      //     console.log('设置 get 操作')
      //     return obj[prop];
      //   },
      //   set: function (obj, prop, value) {
      //     console.log('设置 set 操作', obj, prop, value)
      //     obj[prop] = value;
      //   }
      // });

      // proxy.time = 35; // 设置 set 操作
      // console.log(proxy.time); // 设置 get 操作 // 35

      // function createArray(...elements) {
      //   let handler = {
      //     get(target, propKey, receiver) {
      //       let index = Number(propKey);
      //       if (index < 0) {
      //         propKey = String(target.length + index);
      //       }
      //       return Reflect.get(target, propKey, receiver);
      //     }
      //   };

      //   let target = [];
      //   target.push(...elements);
      //   return new Proxy(target, handler);
      // }

      // let arr = createArray('a', 'b', 'c');
      // arr[-1] // c

      // watch api
      function watch(obj, attr, eleId, fnc) {
        let proxy = new Proxy(obj, {
          get(target, prop, receiver) {
            return target[prop]
          },
          set(target, prop, value) {
            target[prop] = value
            document.getElementById(eleId).innerHTML = value
            fnc()
          }
        })
        proxy[attr] = obj[attr]
        return proxy
      }

      let obj = {
        num: 0,
        age: 16
      }
      let proxyNum = watch(obj, 'num', 'num', function () {
        console.log('callback num')
      })
      document.getElementById('addNum').addEventListener('click', function () {
        proxyNum.num += 1
      })

      let proxyAge = watch(obj, 'age', 'age', function () {
        console.log('callback num')
      })
      document.getElementById('addAge').addEventListener('click', function () {
        proxyAge.age += 1
      })
    });
  </script>

  <!-- 深入系列 -->
  <script>
    // 原型
    (() => {
      let Person = function () {
        this.name = 'Person'
        this.getName = function () {
          return this.name
        }
      }
      let person1 = new Person()
      // console.log(person1.getName())

      // 实例 原型对象
      // console.log(Person.prototype)
      // console.log(Reflect.getPrototypeOf(person1) === Person.prototype)
      // console.log(Object.getPrototypeOf(person1) === Person.prototype)

      // 原型对象constructor 指向构造函数
      // console.log(Person)
      // console.log(Person.prototype.constructor === Person)

      // 最上层为null
      // console.log(Object.getPrototypeOf(Object.prototype) === null)

      // 向上查找 原型中获取constructor属性
      console.log(person1.constructor === Person.prototype.constructor)
    });

    // 词法作用域
    (() => {
      // 静态作用域 函数的作用域在函数定义的时候就决定了
      // var scope = "global scope";
      // function checkscope() {
      //   var scope = "local scope";
      //   function f() {
      //     return scope;
      //   }
      //   return f();
      // }
      // console.log(checkscope())

      var scope = "global scope";
      function checkscope() {
        var scope = "local scope";
        function f() {
          return scope;
        }
        return f;
      }
      console.log(checkscope()())
    });

    // 执行上下文
    (() => {
      // 1. 进入执行上下文
      // 1. 函数的所有形参
      // 2. 函数声明
      // 3. 变量声明  如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
      // 2. 代码执行

      // 未用关键字声明  进入执行上下文 函数的所有形参提前声明不包含 (报错)
      // console.log(a)
      // a = 1

      // 进入执行上下文 函数的所有形参提前声明 为undefined (undefined 变量声明提升但初始化赋值不会 代码执行时才赋值)
      // console.log(a)
      // var a = 1

      // 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
      console.log(foo); // 函数

      function foo() {
        console.log("foo");
      }

      var foo = 1;
    });

    // 闭包
    (() => {
      let data = []
      // for(var i = 0; i < 3; i++) {
      // for(let i = 0; i < 3; i++) {
      //   data.push(() => {
      //     console.log(i)
      //   })
      // }

      for (let i = 0; i < 3; i++) {
        data.push(
          () => {
            ((i) => {
              console.log(i)
            })(i)
          }
        )
      }

      data[0]()
      data[1]()
      data[2]()
    });

    (() => {
      // 可以理解为：同一个函数形成的多个闭包的值都是相互独立的。
      // var t = function () {
      //   var n = 99;
      //   var t2 = function () {
      //     n++
      //     console.log(n)
      //   }
      //   return t2;
      // };

      // var a1 = t();
      // var a2 = t();

      // a1(); // 100
      // a1(); // 101

      // a2(); // 100
      // a2(); // 101

      let nAdd;
      let t = () => {
        let n = 99;
        nAdd = () => {
          n++;
        };
        let t2 = () => {
          console.log(n);
        };
        return t2;
      };

      let a1 = t();
      let a2 = t(); // nAdd被重新赋值 关联到a2函数作用域

      nAdd();
      a1()
      a2()
    });

    // call 模拟
    (() => {
      // 基础调用 this指向
      // Function.prototype.call2 = function (context) {
      //   console.log(this)
      //   // 首先要获取调用call的函数，用this可以获取
      //   context.fn = this;
      //   context.fn();
      //   delete context.fn;
      // }

      // // 测试一下
      // var foo = {
      //   value: 1
      // };

      // function bar() {
      //   console.log(this.value);
      // }

      // bar.call2(foo); // 1

      // 不定长入参 
      // Function.prototype.call2 = function (context) {
      //   context.fn = this;
      //   var args = [];
      //   for (var i = 1, len = arguments.length; i < len; i++) {
      //     args.push('arguments[' + i + ']');
      //     // args.push(arguments[i]);
      //   }
      //   eval('context.fn(' + args + ')');
      //   // context.fn(...args)
      //   delete context.fn;
      // }

      // // 测试一下
      // var foo = {
      //   value: 1
      // };

      // function bar(name, age) {
      //   console.log(name)
      //   console.log(age)
      //   console.log(this.value);
      // }

      // bar.call2(foo, 'kevin', 18);

      // 入参为null情况 函数返回值
      Function.prototype.call2 = function (context) {
        var context = context || window;
        context.fn = this;

        var args = [];
        for (var i = 1, len = arguments.length; i < len; i++) {
          args.push('arguments[' + i + ']');
        }

        var result = eval('context.fn(' + args + ')');

        delete context.fn
        return result;
      }

      // 测试一下
      value = 2;

      var obj = {
        value: 1
      }

      function bar(name, age) {
        console.log(this.value);
        return {
          value: this.value,
          name: name,
          age: age
        }
      }

      // console.log(bar.call2(null))

      console.log(bar.call2(obj, 'kevin', 18));
    });

    // apply 
    (() => {
      Function.prototype.apply2 = function (context, arr) {
        var context = context || window;
        context.fn = this;

        var result;
        if (!arr) {
          result = context.fn();
        }
        else {
          var args = [];
          for (var i = 0, len = arr.length; i < len; i++) {
            args.push('arr[' + i + ']');
          }
          result = eval('context.fn(' + args + ')')
        }

        delete context.fn
        return result;
      }

      value = 2;

      var obj = {
        value: 1
      }

      function bar(name, age) {
        console.log(this.value);
        return {
          value: this.value,
          name: name,
          age: age
        }
      }

      // console.log(bar.apply2(null))

      console.log(bar.apply2(obj, ['kevin', 18]));
    });

    // 类数组 arguments
    (() => {
      // callee 属性 闭包
      var data = [];

      for (var i = 0; i < 3; i++) {
        (data[i] = function () {
          console.log(arguments.callee.i)
        }).i = i;
      }

      data[0]();
      data[1]();
      data[2]();
    });

    (() => {
      function Person(name) {
        this.name = name;
        if (typeof this.getName != "function") {
          Person.prototype = {
            constructor: Person,
            getName: function () {
              console.log(this.name);
            }
          }
          // return new Person(name); // 字面量赋值后重新初始化
        }
      }

      var person1 = new Person('kevin');
      var person2 = new Person('daisy');

      // 报错 并没有该方法
      person1.getName(); // 此时实际原型对象中并没有该方法

      // 注释掉上面的代码，这句是可以执行的。
      person2.getName();
    });

    // 继承
    (() => {
      // 原型链继承 引用类型的属性会被所有实例共享
      // function Parent() {
      //   this.name = 'parent'
      //   this.nums = [1, 2]
      //   Parent.prototype.getName = function() {
      //     console.log(this.name)
      //   }
      // }

      // function Child() {}

      // Child.prototype = new Parent()
      // let child1 = new Child()
      // child1.nums.push(3)

      // let child2 = new Child()
      // console.log(child2.nums)

      // 借用构造函数 经典继承
      // 1.可以在 Child 中向 Parent 传参
      // 2.避免了引用类型的属性被所有实例共享
      // function Parent(nums) {
      //   this.nums = nums
      //   this.names = ['li', 'wang']
      // }
      // function Child(nums) {
      //   Parent.call(this, nums)
      // }
      // let child1 = new Child([1, 2])
      // child1.names.push('sha')
      // console.log(child1.names)

      // let child2 = new Child()
      // console.log(child2.names)

      // 组合继承 融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式
      // function Parent(name) {
      //   this.name = name
      //   this.colors = ['black', 'white']
      // }

      // Parent.prototype.getName = function () {
      //     console.log(this.name)
      // }

      // function Child(name, age) {
      //   Parent.call(this, name)
      //   this.age = age
      // }

      // Child.prototype = new Parent()

      // let child1 = new Child('kevin', 18);
      // child1.colors.push('pink');
      // console.log(child1.name);
      // console.log(child1.age);
      // console.log(child1.colors);
      // child1.getName()

      // let child2 = new Child('Tom', 22);
      // child2.colors.push('blue');
      // console.log(child2.name);
      // console.log(child2.age);
      // console.log(child2.colors);
      // child2.getName()

      // 原型式继承 包含引用类型的属性值始终都会共享相应的值 这点跟原型链继承一样
      // function Parent(obj) {
      //   let fn = function() {}
      //   fn.prototype = obj
      //   return new fn()
      // }
      // let obj = {
      //   name: 'obj',
      //   nums: [1, 2]
      // }
      // let parent1 = new Parent(obj)
      // let parent2 = new Parent(obj)

      // parent1.name = 'p1'
      // parent1.nums.push(3)
      // console.log(parent1.name)
      // console.log(parent2.name)
      // console.log(parent1.nums)
      // console.log(parent2.nums)

      // 寄生式继承 创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。
      // function Parent(obj) {
      //   let cloneObj = Object.create(obj)
      //   cloneObj.name = 'cloneObj'
      //   cloneObj.getName = function() {
      //     console.log(this.name)
      //   }
      //   return cloneObj
      // }
      // let parent1 = new Parent({attr1: 'attr'})
      // parent1.getName()

      // 寄生组合式继承
      function Parent(name) {
        this.name = name;
        this.colors = ['red', 'blue', 'green'];
      }

      Parent.prototype.getName = function () {
        console.log(this.name)
      }

      function Child(name, age) {
        Parent.call(this, name);
        this.age = age;
      }

      // 关键的三步
      // let F = function () { };

      // F.prototype = Parent.prototype;

      // Child.prototype = new F();

      function object(o) {
        function F() { }
        F.prototype = o;
        return new F();
      }

      function prototype(child, parent) {
        var prototype = object(parent.prototype);
        prototype.constructor = child;
        child.prototype = prototype;
      }

      prototype(Child, Parent);

      var child1 = new Child('kevin', '18');

      console.log(child1);

    });
  </script>

  <script>
    (() => {
      // 数据更新监听
      function watch(obj, attr, fnc) {
        let proxy = new Proxy(obj, {
          get() {
            return obj[attr]
          },
          set(target, prop, value) {
            target[prop] = value
            fnc(value)
          }
        })
        proxy[attr] = obj[attr]
        return proxy
      }
      let data = { count: 0 }
      let countEle = document.getElementById('mouseContainer')
      let countProxy = watch(data, 'count', function (value) {
        countEle.innerHTML = value
      })

      const debounce = function (fn, delay, immediate = false) {
        let timer = null
        let result = 'result'
        let interFn = function () {
          let context = this
          if (immediate) {
            if (!timer) {
              fn.apply(context, [arguments, result])
            }
          }
          clearTimeout(timer)
          timer = setTimeout(() => {
            fn.apply(context, [arguments, result])
            timer = null
          }, delay)
        }
        interFn.cancel = function() {
          clearTimeout(timer)
          timer = null
        }
        return interFn
      }
      let mouseFn = debounce(function(arguments, result) {
        console.log('this', this)
        // console.log('event', event)
        console.log('arguments', arguments)
        console.log('result', result)
        countProxy.count++
      }, 10000, true)
      countEle.onmousemove = mouseFn

      let cancelEle = document.getElementById('mouseCancel')
      cancelEle.onclick = function() {
        mouseFn.cancel()
      }
    })();
  </script>